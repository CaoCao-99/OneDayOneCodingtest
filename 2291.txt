Sequence

문제
{
N, M, K가 주어질 때, A1 ≤ A2 ≤ ... ≤ AN 이고, A1 + A2 + ... + AN = M을 만족하는 수열 중 사전 순으로 K번째 수열을 출력한다. 모든 Ai는 자연수이다.

예를 들어, N = 4, M = 9, K = 3 이었으면,

1 1 1 6
1 1 2 5
1 1 3 4
1 2 2 4
1 2 3 3
2 2 2 3
총 6개가 가능한데 3번째 수열 1 1 3 4이 정답이다.
}

입력
{
첫째 줄에 N, M, K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ M ≤ 220, 1 ≤ K ≤ 2,147,483,647)
}

출력
{
    합이 M인 길이가 N인 수열 중 K번째 수열을 출력한다. 항상 답이 존재 하는 경우만 입력으로 주어진다.
}

예제 입력 1 
{
4 9 3
}

예제 출력 1 
{
    1 1 3 4
}

풀이 방법
{
    K의 범위가 매우 크기 때문에 저 순서에 해당하는 값을 얻기 위해서는 무언가 꼼수를 사용해야 한다. 그냥 순차적으로 접근해도 시간 초과 발생

    DP를 사용해서 문제를 해결해야한다.

    dp[원하는 값][수열의 크기] = 가능한 수열의 개수(예시, dp[4][1] = 1, dp[4][2] = 2, dp[4][3] = 1) 

    이 dp 배열에서 규칙을 찾을 수 있는데

    위의 주어진 예시로 예를 들면 dp[4][9]는 다음과 같다

    dp[4][9] = dp[3][3] + dp[3][4] + dp[3][5] + dp[3][6]

                    6,5,4,3

    위의 규칙은 반복문을 이용하여 다음과 같이 구현할 수 있다.

    위와 같은 규칙을 생각했는데 이는 문제가 있다.

    dp[3][6]의 경우 1,1,4가 가능한데 이렇게 되면 1,1,4,3으로 수열의 조건을 만족하지 않는다.

    따라서, 마지막 문자가 어떤 것인지도 배열에 추가하면 위의 문제를 해결할 수 있다.

    dp[원하는 값][수열의 크기][마지막 값]

    또한, 이 문제는 사전순으로 출력해야 하기 때문에 앞에서 부터 출발해야 한다.

    따라서 위의 식을 바탕으로 점화식을 세우게 되면 하단과 같다.

    for ad in range(k, m+1):
        dp[i][j][k] = dp[i+1][j+ad][ad]
}

느낀 점
{
    사실 제대로 이해하지 못했다.

    꼭 다시 풀어 볼 것!!
}