1의 개수 세기 다국어
시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
1 초	128 MB	5603	2116	1655	42.005%
문제
두 자연수 A, B가 주어졌을 때, A ≤ x ≤ B를 만족하는 모든 x에 대해 x를 이진수로 표현했을 때 1의 개수의 합을 구하는 프로그램을 작성하시오.

즉, f(x) = x를 이진수로 표현 했을 때 1의 개수라고 정의하고, 아래 식의 결과를 구하자.

 
\[\sum_{x=A}^{B}{f(x)}\] 

입력
첫 줄에 두 자연수 A, B가 주어진다. (1 ≤ A ≤ B ≤ 10 ^ 16)

출력
1의 개수를 세어 출력한다.

예제 입력 1 
2 12
예제 출력 1 
21

풀이 방법
{
    규칙을 잘 찾아 답을 잘 구해야 한다.(제한 시간이 1초인데 값이 1부터 10 ^ 16까지기 때문에 메모리 초과와 시간 초과를 잘 생각해서 해결해야 한다.)

    2의 제곱수 만큼 누적합을 이용하여 배열을 생성하고 이를 이용해서 문제를 해결했다.

    10 ^ 16의 값은 2 ^ 53 ~ 2 ^ 54 이기 때문에 미리 55개의 배열([0]~[54])에 2진수의 1의 개수를 넣어넣고 재귀문을 이용하여 문제를 해결했다.

    ex. sum[3] = (0, 1, 10, 11, 100, 101, 110, 111) = 12

    만약 1 ~ 10을 구하기 위해서는 먼저 10이 속한 배열 값을 알면 된다.
    
    10 = 1010 -> [4][2] -> 4번째 배열에 2번째열(1000, 1001, 1010) 그렇다면 앞에 7까지의 1의 개수 합은 기존에 구한 누적합 배열을 통해 알 수 있다.
    
    sum_b[3] = (0, 1, 01, 10, 100, 101, 110, 111) + 이후, 1000,1001,1010에 대해 맨 앞자리인 1을 제거하게 되면(0,1,10)이 남게된다.

    여기서 앞에 1의 값은 2번째열 즉 3개이기 때문에 1을 3번 더해주고 이후에 남은 인덱스 값(열)인 2를 다시 누적합 배열을 이용하여 구하면 된다.

    이 부분이 조금은 헷갈릴 수도 있는데 차분하게 생각하면 쉽다.

    만약, 남은 값이 0, 1, 10, 11 이었다면 단순히, sum_b[2]를 진행해주면 되지만 앞선 경우(1010 = [4][2])와 마찬가지로 2의 루트값으로 예쁘게 떨어지지 않는다면

    앞선 경우를 반복하여 재귀적으로 문제를 해결할 수 있다.  
    
    위의 경우(0,1,10)을 마저 진행하면 먼저, 3//2 -> 1이 나오게 된다. 따라서, sum_b[1] + 나머지(2 - 2^1) + 1(인덱스 값이기 떄문에 1 추가) + rec(나머지(2 - 2^1))

    최종 재귀함수를 보게 되면 다음과 같다.

    def rec(현재 값):
    몫  = int(현재 값의 log2)
    return sum_b[몫] + 나머지(현재 값  - 2^몫) + rec(나머지)
    위의 함수를 이용하면 문제를 해결할 수 있다.

    결과적으로 log2를 활용해서 계산 횟수를 줄이고 재귀함수를 이용해서 풀 수 있는 문제이다.
}

느낀점
{
    우선, 규칙을 찾는 것은 어렵지 않았지만 누적합을 이용하는데 조금 어려움이 있었고 무엇보다 숫자가 너무 커지다 보니 index 계산을 잘못하여 계산 실수를 많이했다.

    문제의 난이도는 높지 않았으나 귀찮은 점이 많은 문제였다.

    다음부터 이와 비슷한 문제는 작은 값부터 직접 손으로 풀어보고 점화식을 세워 진행해야 확실할 것 같다.
}