숨바꼭질 4 스페셜 저지

문제
{
수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 

수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 

순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.
}

입력
{
첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.
}

출력
{
첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

둘째 줄에 어떻게 이동해야 하는지 공백으로 구분해 출력한다.
}

예제 입력 1 
{
5 17
}

예제 출력 1 
{
4
5 10 9 18 17
}

예제 입력 2 
{
5 17
}

예제 출력 2 
{
4
5 4 8 16 17
}

풀이 방법
{
    이전에 풀었던 스타트링크와 마찬가지로 BFS를 이용하여 문제를 해결하면 될 것 같다.
}

최종 풀이 방법
{
    우선, 문제를 푼 방법은 위의 방법과 유사하지만 본 문제는 한번 방문하면 무조건 그것이 최적으 수라고 볼 수 있다. 

    BFS로 풀었기 때문에 먼저 방문했을 때의 time이 가장 짧을 수 밖에 없다.

    위의 방법을 알았다고 해도 경로를 출력해야 하는데 이 부분을 가장 주의해야 한다.

    초반에 3가지 방법으로 최대한 메모리를 줄이고자 노력했지만 실패했고 결과적으로는 값을 한번만 담아야 한다는 것을 깨달았다.

    따라서, 최대 개수 만큼 배열을 생성하고 각 배열에 현재 위치에 오기 전 위치 정보를 넣어주고 

    재귀적으로 뒤(도착지)에서 앞(출발지)로 위치 정보를 받아오면 된다.

    위의 방법을 사용할 때 주의할 점은 재귀문을 실제 재귀함수를 제작해서 호출할 시, 재귀 문 반복 횟수에 제한을 걸어 두었기에 while 문을 이용해서 재귀문을 대체해야 한다.

    결과적으로, 이동 정보(하나의 배열로 저장), 방문 한 경우, 무조건 최선의 수 이 2가지를 알아야만 메모리초과 없이 문제를 해결할 수 있었다.
}

느낀 점
{
    개인적으로 이전에 풀었던 문제와 유사해서 굉장히 쉽게 넘어갈 줄 알았는데

    오랜만에 메모리 초과가 나와 당황했다. 

    메모리 초과가 나오는 것을 자주 염두해두고 이 문제는 꼭 다시 풀어야 할 것 같다.
}
