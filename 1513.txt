경로 찾기 

문제
{
세준이는 크기가 N*M인 직사각형 도시에 살고 있다. 또, 세준이의 집은 (1, 1)에 있고, 학원은 (N, M)에 있고, 오락실이 C개 있다.

세준이의 현재 위치가 (r, c) 일 때, (r+1, c) 또는 (r, c+1)로만 이동할 수 있다. 

오락실을 방문할 때는 규칙이 하나 있는데, 오락실 번호가 증가하는 순서대로 가야한다는 것이다. 

2번 오락실을 먼저 가고, 그 후에 1번 오락실을 가면 안 되고, 2번 오락실을 가려면, 그 전에 아무 오락실도 가지 않거나, 1번 오락실을 방문했을 때만 가능하다.

세준이는 오락실을 K번 방문해서 학원에서 도착하는 경로의 경우의 수가 궁금해지기 시작했다. 

오락실을 0개 방문했을 때부터, C개 방문했을 때 까지 경우의 수를 출력하는 프로그램을 작성하시오.

}

입력
{
첫째 줄에 N M C가 주어진다. N과 M은 50보다 작거나 같은 자연수이고, C는 50보다 작거나 같은 자연수 또는 0이다. 

째 줄부터 C개의 줄에 1번 오락실부터 C번 오락실까지 위치가 차례대로 주어진다. 

오락실의 위치가 중복되는 경우는 없지만, 오락실의 위치가 (1,1) 또는 (N,M)일 수도 있다.
}


출력
{
첫째 줄에 0개 방문했을 때, 1개 방문했을 때, ..., C개 방문했을 때 총 경로의 개수를 한 줄에 공백을 사이에 두고 출력한다. 

경로의 개수는 1,000,007로 나눈 나머지를 출력한다.
}


예제 입력 1 
{
3 3 2
2 2
3 2
}

예제 출력 1 
{
1 3 2
0개: (1,1) → (1,2) → (1,3) → (2,3) → (3,3)
1개: (1,1) → (2,1) → (2,2) → (2,3) → (3,3), (1,1) → (1,2) → (2,2) → (2,3) → (3,3), (1,1) → (2,1) → (3,1) → (3,2) → (3,3)
2개: (1,1) → (2,1) → (2,2) → (3,2) → (3,3), (1,1) → (1,2) → (2,2) → (3,2) → (3,3)
}

예제 입력 2 
{
6 4 2
5 3
3 2
}

예제 출력 2 
{
    14 24 0
}


예제 입력 3 
{
5 5 3
1 3
2 4
3 5
}

예제 출력 3 
{
42 14 10 4
}

예제 입력 4 
{
50 50 2
50 50
1 1
}

예제 출력 4 
{
0 0 0
}

풀이 방법
{
    dp[현재 위치 y][현재 위치 x][방문한 오락실 개수][최대 오락실 번호]

    위의 dp 배열을 구해서 방문한 오락실 개수가 동일한 dp 값들의 합을 구하면 문제를 해결할 수 있다.

    먼저 오락실의 위치를 orak 배열에 담아두고 dp 배열을 -1로 초기화 시켜준다.

    핵심 포인트는 다음과 같다. 현재 위치에서 올 수 있는 위치의 경우의 수를 더해주면 된다.

    dp[n][m] = dp[n-1][m] + dp[n][m-1]

    위와 같은 간단한 점화식에 조건을 추가해주면 된다.

    가장 위에 적은 점화식과 같이 내가 현재 들어갈 수 있는 최대 오락실 번호와  방문한 오락실 개수를 추가시켜주고

    만약 현재 위치가 오락실이 있는 곳이고 최대 오락실 번호와 같다면 
    
    dp[n][m][k][c] += dp[n][m-1][k-1][~c-1] + dp[n-1][m][k-1][~c-1]과 같다.

    만약, 오락실이 아니라면 dp[n][m][k][c] = dp[n][m-1][k][c] + dp[n-1][m][k][c]와 같다.
}   

느낀 점
{
    다시 풀어 보쟈
}