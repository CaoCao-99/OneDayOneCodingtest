교환

문제
{
0으로 시작하지 않는 정수 N이 주어진다. 이때, M을 정수 N의 자릿수라고 했을 때, 다음과 같은 연산을 K번 수행한다.

1 ≤ i < j ≤ M인 i와 j를 고른다. 그 다음, i번 위치의 숫자와 j번 위치의 숫자를 바꾼다. 이때, 바꾼 수가 0으로 시작하면 안 된다.

위의 연산을 K번 했을 때, 나올 수 있는 수의 최댓값을 구하는 프로그램을 작성하시오.
}

입력
{
첫째 줄에 정수 N과 K가 주어진다. N은 1,000,000보다 작거나 같은 자연수이고, K는 10보다 작거나 같은 자연수이다.
}

출력
{
첫째 줄에 문제에 주어진 연산을 K번 했을 때, 만들 수 있는 가장 큰 수를 출력한다. 만약 연산을 K번 할 수 없으면 -1을 출력한다.
}


예제 입력 1 
{
    16375 1
}

예제 출력 1 
{
    76315
}

예제 입력 2 
{
    132 3
}

예제 출력 2 
{
    312
}

예제 입력 3 
{
    432 1
}

예제 출력 3 
{
    423
}

예제 입력 4 
{
    90 4
}

예제 출력 4 
{
-1
}

예제 입력 5 
{
5 2
}

예제 출력 5 
{
    -1
}

예제 입력 6 
{
    436659 2
}

예제 출력 6 
{
    966354
}

풀이 방법1(고민만 해보고 시도 X)
{
    그리디하게 가장 큰 수를 앞으로 보내고 그 다음 가장 큰 수를 앞으로 보내고 반복하면 문제를 해결할 수 있다.

    단, 변경하는 숫자의 횟수를 다 사용해야 하기 때문에 숫자의 횟수가 최고 숫자를 만들고도 남았을 경우에는 끝에 2개의 숫자를 계속해서 변경해주면 된다.

    위의 방법으로는 최선의 수를 구할 수 없을 것 같다.
}

풀이 방법2
{
    BFS를 이용한다.

    기존의 BFS를 이용할 떄 사용하는 visit 배열을 생성하는데 이때, 인덱스의 의미는 몇 번 고쳤느냐 이다.

    ex. visit[0] -> 0번 고쳤을 때 숫자, visit[1] -> 1번 고쳤을 때 숫자는

    visit[1] -> ['321', '213', '231'] 이렇게 visit에 모든 경우의 수를 넣는다.

    단, 이미 이 값이 동일한 차례에 큐에 들어가있다면 queue에 값을 넣지 않고 visit에도 값을 추가하지 않는다.

    ex. 이전 visit[1] -> ['321', '213', '231'], queue에 의해 새로 나운 숫자 '321' 하지만, 이미 존재

    위의 BFS 탐색을 이용해서 모든 큐에 있는 숫자를 넣어 주고 반복문을 종료한다.

    이후, visit[k]에 해당하는 값 중 가장 큰 값을 출력하면 된다.
}