K번째 수

문제
{
세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 

이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.

배열 A와 B의 인덱스는 1부터 시작한다.
}

입력
{
첫째 줄에 배열의 크기 N이 주어진다. N은 105보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 min(109, N2)보다 작거나 같은 자연수이다.
}

출력
{
B[k]를 출력한다.
}

예제 입력 1 
{
3
7
}

예제 출력 1 
{
6
}

풀이 방법
{
    배열을 실제로 만들게 되면 분명히 메모리 초과가 발생할 것이기에 실제로 배열을 구현하지 않고 문제를 해결해야 한다.

    규칙을 찾아서 해당 인덱스에 맞는 값을 찾아야 한다.

    1 2 3 4
    2 4 6 8
    3 6 9 12
    4 8 12 16

    2x2
    1 2 2 4
    3x3
    1 2 2 3 3 4 6 6 9
    4x4
    1 2 2 3 3 4 4 4 6 6 8 8 9 12 12 16
    1~n * 2

    위의 배열(4x4)과 예시를 하나 들어보자(ex. k = 10)

    k의 값이 위와 같을 때, k의 idx 값은 어떻게 될까

    k의 값 앞에 몇개의 값이 존재하는지 확인하면 idx 값을 알 수 있다.

    개수를 구하기 위한 방법은 해당 숫자(k)를 각 열의 번호로 나누어 주면 된다.

    idx += min(n, k//i)
    
    위의 idx 값은 k가 갖을 수 있는 가장 큰 idx값과 같다.

    역으로 생각하면 k값을 유추해서 넣어보고 해당하는 idx 값과 같은 경우를 찾을 수 있으며 이를 활용하면 메모리 제한에 걸리지 않는다.

    또한, k의 값을 idx와 비교하며 유추하는 것을 Brute하게 진행하면 시간초과가 발생하기 때문에 이진탐색을 사용하여 문제를 해결하겠다.(초기 mid 값 : (1+k) // 2)
}

느낀 점
{
    이진 탐색을 떠올리기 쉽지 않은 문제였을뿐더러 답을 구하는 과정도 쉽지 않았다.

    꼭 다시 풀어봐야 하는 문제!
}