주사위 윷놀이

문제
{
주사위 윷놀이는 다음과 같은 게임판에서 하는 게임이다.



처음에는 시작 칸에 말 4개가 있다.

말은 게임판에 그려진 화살표의 방향대로만 이동할 수 있다. 

말이 파란색 칸에서 이동을 시작하면 파란색 화살표를 타야 하고, 이동하는 도중이거나 파란색이 아닌 칸에서 이동을 시작하면 빨간색 화살표를 타야 한다. 

말이 도착 칸으로 이동하면 주사위에 나온 수와 관계 없이 이동을 마친다.

게임은 10개의 턴으로 이루어진다. 

매 턴마다 1부터 5까지 한 면에 하나씩 적혀있는 5면체 주사위를 굴리고, 도착 칸에 있지 않은 말을 하나 골라 주사위에 나온 수만큼 이동시킨다.

말이 이동을 마치는 칸에 다른 말이 있으면 그 말은 고를 수 없다. 단, 이동을 마치는 칸이 도착 칸이면 고를 수 있다.

말이 이동을 마칠 때마다 칸에 적혀있는 수가 점수에 추가된다.

주사위에서 나올 수 10개를 미리 알고 있을 때, 얻을 수 있는 점수의 최댓값을 구해보자.
}

입력
{
첫째 줄에 주사위에서 나올 수 10개가 순서대로 주어진다.
}

출력
{
얻을 수 있는 점수의 최댓값을 출력한다.
}

예제 입력 1 
{
1 2 3 4 1 2 3 4 1 2
}

예제 출력 1 
{
190
}

예제 입력 2 
{
1 1 1 1 1 1 1 1 1 1
}

예제 출력 2 
{
133
}

예제 입력 3 
{
5 1 2 3 4 5 5 3 2 4
}

예제 출력 3 
{
214
}

예제 입력 4 
{
5 5 5 5 5 5 5 5 5 5
}

예제 출력 4 
{
130
}

풀이 방법1(실패)
{
    DFS를 이용해서 문제를 해결할 수 있다.

    4개의 말을 재귀문을 이용해서 계속 값을 보내주면 된다.

    for 반복문을 이용해서 4개의 말을 차례대로 넣고 진행시켜 주는데 이때, 말이 방문했었던 곳을 또 다시 방문하게 된다면 시간이 더 걸리기 때문에

    문자열을 이용해서 visit 배열을 생성했다. 
}

풀이 방법2(실패)
{
    위의 방법을 시도해봤는데 생각하지 못한 부분이 있어 실패했다.

    우선 말의 위치가 겹쳐서는 안되고 맵을 짜는 것도 어려움이 있었기 때문에 모든 경우의수
    
    (가장 돌아가는 방법, 10에서 가는 법, 20에서 가는 법, 30에서 가는 법)를 나누어서 맵을 구성했다.
}

풀이 방법3
{
    위의 방법을 시도하는 중 맵을 다르게 한다고 해도 10, 20, 30에 해당하는 맵은 동일한 맵을 포함하고 있기 때문에 그부분 또한 예외처리를 해줘야 한다.
}

풀이 방법4
{
    위의 방법대로 맵의 공통된 부분을 계산하여 실행했더니 우선 수식이 너무 길어지고 더러워져 문제를 파악하기 어려웠고

    horse 배열 내부에 2개의 원소를 가진 배열들과 직접 값을 넣다보니 문제가 많이 발생했다.

    따라서, 맵과 스코어를 새롭게 1차원 배열로 생성했고 말이 이미 존재하는지 비교하는 문장 또한 인덱스로 비교했기 때문에 쉽게 해결할 수 있었다.
}

느낀 점
{
    될 듯 안될 듯 하는 문제를 풀 때는 최대한 간단하게 푸는 것이 중요한 것 같다.

    또한, 안되더라도 될 때까지 하는 것보다는 너무 많은 시간을 쏟지 않고 넘어가는 것이 좋은 것 같다.

    이 문제도 꼭 다시 풀어보자
}